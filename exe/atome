#!/usr/bin/env ruby
# frozen_string_literal: true

require 'fileutils'
require 'securerandom'
require 'digest/sha2'
require 'pathname'
require 'opal'
require 'parser'
require 'uglifier'

# utils

def modify_and_copy_file(source_path, destination_path, destination_dir)

  file_content = File.read(source_path)
  cleaned_content = file_content.encode('UTF-8', 'binary', invalid: :replace, undef: :replace, replace: '')
  modified_code = cleaned_content.gsub(/require\s+(['"])(.*?)\1/) do |match|
    quote = $1
    relative_path = $2
    if relative_path.start_with?('./')
      relative_path_copy = "#{relative_path}"
      relative_path_copy.slice!(0, 2)
      destination_dir_copy = "#{destination_dir}"
      destination_dir_copy.slice!(0, 2)
      "require #{quote}#{relative_path_copy}#{quote}"
    else
      match
    end

  end
  File.write(destination_path, modified_code)
end

def process_directories(source_dir, destination_dir)

  Dir.entries(source_dir).each do |entry|
    next if entry == '.' || entry == '..'

    source_path = File.join(source_dir, entry)
    destination_path = File.join(destination_dir, entry)

    if File.directory?(source_path)
      Dir.mkdir(destination_path) unless Dir.exist?(destination_path)
      process_directories(source_path, destination_path)
    elsif File.file?(source_path)
      modify_and_copy_file(source_path, destination_path, destination_dir)
    end
  end
end

# builders
def build_aui(destination, project_name)
  path = "#{destination}/#{project_name}/src/utilities/"
  FileUtils.mkdir_p(path) unless Dir.exist?(path)
  uuid = SecureRandom.uuid
  sha = Digest::SHA256.hexdigest(uuid)
  coded_id = sha.gsub('-', '_')
  aui_file = <<~STR
    class Atome
      def self.aui
        "#{coded_id}"
      end
    end
  STR
  File.new("#{path}aui.rb", 'w')
  File.open("#{path}aui.rb", 'w') do |f|
    f.puts aui_file
  end
  # now building opal version
  js_directory = "#{destination}/#{project_name}/src/js"
  opal_js = "#{js_directory}/aui.js"
  File.new opal_js, 'w'
  # we add platform_specific script to the Opal framework
  opal_content = Opal::Builder.build("#{path}aui.rb").to_s
  File.open(opal_js, 'w') do |f|
    f.puts opal_content
  end

end

def build_host_mode(destination, project_name, mode)
  path = "#{destination}/#{project_name}/src/utilities/"
  FileUtils.mkdir_p(path) unless Dir.exist?(path)
  host_type = <<~STR
    class Atome
      def self.host
        "#{mode}"
      end
    end
  STR
  File.new("#{path}host_mode.rb", 'w')
  File.open("#{path}host_mode.rb", 'w') do |f|
    f.puts host_type
  end
  # now building opal version
  js_directory = "#{destination}/#{project_name}/src/js"
  opal_js = "#{js_directory}/host_mode.js"
  File.new opal_js, 'w'
  # we add platform_specific script to the Opal framework
  opal_content = Opal::Builder.build("#{path}host_mode.rb").to_s
  File.open(opal_js, 'w') do |f|
    f.puts opal_content
  end
end

# opal compilation
def build_opal_application(_source, destination, project_name)
  # first we need to remplace all './require ' with require  so opal can parse the path
  Dir.mkdir("#{destination}/#{project_name}/tmp") unless Dir.exist?("#{destination}/#{project_name}/tmp")
  unless Dir.exist?("#{destination}/#{project_name}/tmp/application")
    Dir.mkdir("#{destination}/#{project_name}/tmp/application")
  end
  process_directories("#{destination}/#{project_name}/application", "#{destination}/#{project_name}/tmp/application")

  opal_compiler_content = <<STR
# frozen_string_literal: true

require 'opal'
application_js = "../../src/js/application.js"
builder = Opal::Builder.new
builder.append_paths("./")
application_content = builder.build("./index.rb").to_s
File.open(application_js, 'w') do |f|
  f.puts application_content
end
STR

  # we create an hidden file
  opal_compiler = "#{destination}/#{project_name}/tmp/application/.opal_compiler.rb"
  File.open(opal_compiler, 'w') do |f|
    f.puts opal_compiler_content
  end
  if RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/
    # Code à exécuter sous Windows
    `cd #{destination}\\#{project_name}\\tmp\\application\\ && echo %cd% && ruby .opal_compiler.rb`

  elsif RbConfig::CONFIG['host_os'] =~ /darwin|mac os/
    # Code à exécuter sous MacOS
    `cd #{destination}/#{project_name}/tmp/application/;pwd;ruby .opal_compiler.rb`

  else
    # Code à exécuter sous Unix/Linux
    `cd #{destination}/#{project_name}/tmp/application/;pwd;ruby .opal_compiler.rb`

  end

end

def add_to_application_folder(script_source, destination, project_name)
  # this method is to add addition script to the application folder (useful for test per example)
  destination_dir = "#{destination}/#{project_name}/application"
  FileUtils.cp_r(Dir["#{script_source}/*"], destination_dir)
end

def build_opal_library(atome_source, destination, project_name, production = nil)
  user_project_path = "#{destination}/#{project_name}"
  opal_directory = "#{user_project_path}/src/js/opal"
  opal_js = "#{opal_directory}/opal.js"
  Dir.mkdir(opal_directory) unless File.directory?(opal_directory)
  File.new opal_js, 'w'
  # we add platform_specific script to the Opal framework
  opal_content = Opal::Builder.build("#{atome_source}/lib/platform_specific/opal/opal.rb").to_s
  File.open(opal_js, 'w') do |f|
    f.puts opal_content
  end
end

def create_application(source, destination, project_name)
  project_path = "#{destination}/#{project_name}"
  FileUtils.mkdir_p(destination) unless Dir.exist?(destination)
  FileUtils.mkdir_p(project_path) unless Dir.exist?(project_path)
  files_list = ['application', 'server', 'src', 'src-tauri', 'src-wasm', 'Guardfile', 'Rakefile']
  file_to_refresh = ['application', 'server', 'src', 'src-tauri', 'Rakefile']
  # we delete many folder to ensure they'll refreshed
  file_to_refresh.each do |file|
    FileUtils.rm_rf("#{destination}/#{project_name}/#{file}")
  end
  # we copy all folder to be refreshed
  files_list.each do |file|
    FileUtils.cp_r("#{source}/vendor/assets/#{file}", "#{destination}/#{project_name}/#{file}") unless Dir.exist?(file)
  end
  build_aui(destination, project_name)
end

def update_application(source, destination, project_name)
  project_path = "#{destination}/#{project_name}"
  FileUtils.mkdir_p(destination) unless Dir.exist?(destination)
  FileUtils.mkdir_p(project_path) unless Dir.exist?(project_path)
  files_list = ['application', 'server', 'src', 'src-tauri', 'src-wasm', 'Guardfile', 'Rakefile']
  file_to_refresh = ['application', 'server', 'src',]
  # we delete many folder to ensure they'll refreshed
  file_to_refresh.each do |file|
    FileUtils.rm_rf("#{destination}/#{project_name}/#{file}")
  end
  # we copy all folder to be refreshed
  files_list.each do |file|
    FileUtils.cp_r("#{source}/vendor/assets/#{file}", "#{destination}/#{project_name}/#{file}") unless Dir.exist?(file)
  end
  build_aui(destination, project_name)
end

def build_opal_parser(source, destination, project_name)

  parser_js = "#{destination}/#{project_name}/src/js/opal/opal_parser.js"
  File.new parser_js, 'w'
  parser_content = Opal::Builder.build("#{source}/lib/platform_specific/opal/opal_parser.rb").to_s
  File.open(parser_js, 'w') do |f|
    f.puts parser_content
  end
end

def build_atome_kernel_for_opal(source, destination, project_name)
  #  now lets build the atome kernel
  atome_directory = "#{destination}/#{project_name}/src/js/atome"
  kernel_js = "#{atome_directory}/kernel.js"
  File.new kernel_js, 'w'
  builder = Opal::Builder.new
  builder.append_paths("#{source}/lib/")
  kernel_content = builder.build("#{source}/lib/atome.rb").to_s
  File.open(kernel_js, 'w') do |f|
    f.puts kernel_content
  end
end

def build_opal_extensions(source, destination, project_name)
  opal_directory = "#{destination}/#{project_name}/src/js/opal"
  extensions_js = "#{opal_directory}/atome_opal_extensions.js"
  File.new extensions_js, 'w'
  builder = Opal::Builder.new
  builder.append_paths("#{source}/lib/platform_specific/opal/")
  extensions_content = builder.build("#{source}/lib/platform_specific/opal/atome_opal_extensions.rb").to_s
  File.open(extensions_js, 'w') do |f|
    f.puts extensions_content
  end
end

# wasm compilation
def wasm_common(source, destination, project_name, wasi_file, host_mode, script_source = nil)
  # create_application(source, destination, project_name)
  # the line below is to add addition script to the application folder (useful for test per example)
  add_to_application_folder(script_source, destination, project_name) if script_source
  # build host_mode
  build_host_mode(destination, project_name, host_mode)
  # build wasm
  build_for_wasm(source, destination, project_name, wasi_file)
end

def wasm_initialize (source, destination, project_name, wasi_source)
  application_location = "#{destination}/#{project_name}"
  wasm_location = "#{application_location}/src/wasm/"
  Dir.mkdir(wasm_location) unless Dir.exist?(wasm_location)

  wasm_temp_folder = "#{application_location}/tmp"
  Dir.mkdir(wasm_temp_folder) unless Dir.exist?(wasm_temp_folder)
  #### IMPORTANT TO REFRESH RUBY WASM TO THE LATEST VERSION, (when ruby_browser get far too large)
  # and UNCOMMENT the line  below : ('curl -LO ....')
  unless File.exist?("#{wasm_temp_folder}/ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz")

    if RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/
      `cd /d %wasm_temp_folder% && curl -LO https://github.com/ruby/ruby.wasm/releases/download/2023-11-17-a/ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz
`
    elsif RbConfig::CONFIG['host_os'] =~ /darwin|mac os/
      # Code à exécuter sous MacOS
      # `cd #{wasm_temp_folder};curl -LO https://github.com/ruby/ruby.wasm/releases/latest/download/ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz`
      `cd #{wasm_temp_folder};curl -LO https://github.com/ruby/ruby.wasm/releases/download/2023-11-17-a/ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz`
      # debug :  https://github.com/ruby/ruby.wasm/releases/download/2023-11-17-a/ruby-3_2-wasm32-unknown-wasi-minimal-js-debug.tar.gz
      # standard :     `cd #{wasm_temp_folder};curl -LO https://github.com/ruby/ruby.wasm/releases/download/2023-11-17-a/ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz`

    else
      # Code à exécuter sous Unix/Linux
      `cd #{wasm_temp_folder};curl -LO https://github.com/ruby/ruby.wasm/releases/download/2023-11-17-a/ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz`
    end

  end

  if RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/
    # Code à exécuter sous Windows
    `cd /d %wasm_temp_folder% && 7z x ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz`
    `move %wasm_temp_folder%\\3_2-wasm32-unknown-wasi-full-js\\usr\\local\\bin\\ruby %wasm_temp_folder%\\system_ruby_browser.wasm`
    `del %application_location%\\src\\wasm\\ruby_browser.wasm`

  elsif RbConfig::CONFIG['host_os'] =~ /darwin|mac os/
    # Code à exécuter sous MacOS
    `cd #{wasm_temp_folder}; tar xfz ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz`
    `mv #{wasm_temp_folder}/3_2-wasm32-unknown-wasi-full-js/usr/local/bin/ruby #{wasm_temp_folder}/system_ruby_browser.wasm`
    `rm -f #{application_location}/src/wasm/ruby_browser.wasm`
  else
    # Code à exécuter sous Unix/Linux
    `cd #{wasm_temp_folder}; tar xfz ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz`
    `mv #{wasm_temp_folder}/3_2-wasm32-unknown-wasi-full-js/usr/local/bin/ruby #{wasm_temp_folder}/system_ruby_browser.wasm`
    `rm -f #{application_location}/src/wasm/ruby_browser.wasm`
  end

  cmd = <<~STRDELIM
    #{application_location}/src-wasm/wasm/#{wasi_source} pack #{wasm_temp_folder}/system_ruby_browser.wasm
    --mapdir usr::#{wasm_temp_folder}/3_2-wasm32-unknown-wasi-full-js/usr
    --mapdir lib::#{source}/lib/
    --mapdir /::#{application_location}/application/
    --mapdir utilities::#{application_location}/src/utilities/
    -o #{application_location}/src/wasm/ruby_browser.wasm
  STRDELIM
  cleaned_cmd = cmd.lines.reject { |line| line.start_with?('#') }.join
  command = cleaned_cmd.chomp.gsub("\n", ' ')
  system(command)
end

def guard_check
  loop do
    sleep 1
  end
  nil unless ARGV.include?('guard')
end

def build_for_wasm(source, destination, project_name, wasi_file)
  wasm_initialize(source, destination, project_name, wasi_file)
end

def build_for_osx(destination, mode = :dev)
  # dev or build
  if RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/
    # Code à exécuter sous Windows
    `cd /d #{destination} && cargo tauri %mode%`

  elsif RbConfig::CONFIG['host_os'] =~ /darwin|mac os/
    # Code à exécuter sous MacOS
    `cd #{destination};cargo tauri #{mode}`
  else
    # Code à exécuter sous Unix/Linux
    `cd #{destination};cargo tauri #{mode}`
  end


end

def build_for_server(destination, project_name, port, production)
  prod = '--env production' if production
  if RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/
    # Code à exécuter sous Windows
   `cd /d #{destination}\\#{project_name}\\server && puma --port %port% %prod%`
  elsif RbConfig::CONFIG['host_os'] =~ /darwin|mac os/
    # Code à exécuter sous MacOS
    `cd #{destination}/#{project_name}/server;puma --port #{port} #{prod}`
  else
    # Code à exécuter sous Unix/Linux
    `cd #{destination}/#{project_name}/server;puma --port #{port} #{prod}`
  end

end

# def run_application(build_target, location, port = 9292, production = false)
#   build_app(location, nil)
#   run_case(build_target, location, port, production)
# end

# below we analyse the ARGV
location = '/'
project_name = ARGV[1]

if RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/
  # Code à exécuter sous Windows
  destination = `cd`.chomp
elsif RbConfig::CONFIG['host_os'] =~ /darwin|mac os/
  # Code à exécuter sous MacOS
  destination = `pwd`.chomp
else
  # Code à exécuter sous Unix/Linux
  destination = `pwd`.chomp
end

source = Pathname(__FILE__).parent.parent.to_s

wasi_file = 'wasi-vfs-osx_arm' # default to osx arm
# TODO : get wasi params from ARG to allow compile on windows / Unix
if ARGV.include?('create')
  create_application(source, destination, project_name)
  # create_application(source, destination, project_name, production)
  wasm_common(source, destination, project_name, wasi_file, :universal)
  # build opal
  build_opal_library(source, destination, project_name)
  # build parser
  build_opal_parser(source, destination, project_name)
  # build atome kernel
  build_atome_kernel_for_opal(source, destination, project_name)
  # build Opal extensions
  build_opal_extensions(source, destination, project_name)
  # build application
  build_opal_application(source, destination, project_name)
end

if ARGV.include?('update')
  # TODO: also update index.html and all other files except the application folder
  # first we delete everything but application
  folders_to_keep = ['application']
  Dir.foreach(destination) do |item|
    item_path = File.join(destination, item)
    if File.directory?(item_path) && !folders_to_keep.include?(item)
      FileUtils.rm_rf(item_path) unless item == '.' || item == '..'
    elsif File.file?(item_path)
      File.delete(item_path)
    end
  end
  # now we update
  puts "#{source}/vendor/assets"

  update_source = "#{source}/vendor/assets"

  Dir.glob("#{update_source}/*").each do |item|
    target = File.join(destination, File.basename(item))
    FileUtils.cp_r(item, target) unless File.exist?(target)
  end
end

if ARGV.include?('guard')
  Thread.new do
    sleep 1.2
    Dir.chdir("./#{location}") do
      `guard`
    end
  end
end

if ARGV.include?('run')

  if RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/
    # Code à exécuter sous Windows
    current_path = `cd`.chomp
  elsif RbConfig::CONFIG['host_os'] =~ /darwin|mac os/
    # Code à exécuter sous MacOS
    current_path = `pwd`.chomp
  else
    # Code à exécuter sous Unix/Linux
    current_path = `pwd`.chomp
  end
  segments = current_path.split("/")
  project_name = segments.last
  destination = segments[0...-1].join("/")
  case ARGV[1]
  when 'opal'
    build_opal_application(nil, destination, project_name)
    `open #{destination}/#{project_name}/src/index_opal.html`
  when 'wasm' # osx wasi
    wasi_file = 'wasi-vfs-osx_arm'
    wasm_common(source, destination, project_name, wasi_file, :pure_wasi)
    `open #{current_path}/src/index.html`
  when 'server'
    build_opal_application(nil, destination, project_name)
    threads = []
    threads << Thread.new do
      sleep 1


      if RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/
        # Code à exécuter sous Windows
        `start "" "#{destination}\\#{project_name}\\src\\index_opal.html`
      elsif RbConfig::CONFIG['host_os'] =~ /darwin|mac os/
        # Code à exécuter sous MacOS
        `open http://localhost:9292`
      else
        # Code à exécuter sous Unix/Linux
        `open http://localhost:9292`
      end

    end
    build_for_server(destination, project_name, 9292, :production)
  when 'osx'
    wasi_file = 'wasi-vfs-osx_arm'
    wasm_common(source, destination, project_name, wasi_file, :tauri)
    build_for_osx(destination)
  when 'android'
    # to be filled
  when 'ios'
    # to be filled
  when 'windows'
    # to be filled
  when 'linux'
    # to be filled
  when 'freebsd'
    # to be filled
  else
    wasi_file = 'wasi-vfs-osx_arm'
    wasm_common(source, destination, project_name, wasi_file, 'pure_wasm')

    if RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/
      # Code à exécuter sous Windows
      `start "" "%current_path%\\src\\index.html"`
    elsif RbConfig::CONFIG['host_os'] =~ /darwin|mac os/
      # Code à exécuter sous MacOS
      `open #{current_path}/src/index.html`
    else
      # Code à exécuter sous Unix/Linux
      `open #{current_path}/src/index.html`
    end

  end

end
