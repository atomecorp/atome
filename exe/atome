#!/usr/bin/env ruby
# frozen_string_literal: true

require 'fileutils'
require 'securerandom'
require 'digest/sha2'
require 'pathname'
require 'opal'
require 'parser'
require 'uglifier'

# utils

def modify_and_copy_file(source_path, destination_path, destination_dir)

  file_content = File.read(source_path)

  modified_code = file_content.gsub(/require\s+(['"])(.*?)\1/) do |match|
    quote = $1
    relative_path = $2
    if relative_path.start_with?('./')
      relative_path_copy = "#{relative_path}"
      relative_path_copy.slice!(0, 2)
      destination_dir_copy = "#{destination_dir}"
      destination_dir_copy.slice!(0, 2)
      "require #{quote}#{relative_path_copy}#{quote}"
    else
      match
    end

  end
  File.write(destination_path, modified_code)
end

def process_directories(source_dir, destination_dir)

  Dir.entries(source_dir).each do |entry|
    next if entry == '.' || entry == '..'

    source_path = File.join(source_dir, entry)
    destination_path = File.join(destination_dir, entry)

    if File.directory?(source_path)
      Dir.mkdir(destination_path) unless Dir.exist?(destination_path)
      process_directories(source_path, destination_path)
    elsif File.file?(source_path)
      modify_and_copy_file(source_path, destination_path, destination_dir)
    end
  end
end

# builders
def build_aui(destination, project_name)
  path = "#{destination}/#{project_name}/src/utilities/"
  FileUtils.mkdir_p(path) unless Dir.exist?(path)
  uuid = SecureRandom.uuid
  sha = Digest::SHA256.hexdigest(uuid)
  coded_id = sha.gsub('-', '_')
  aui_file = <<~STR
    class Atome
      def self.aui
        "#{coded_id}"
      end
    end
  STR
  File.new("#{path}aui.rb", 'w')
  File.open("#{path}aui.rb", 'w') do |f|
    f.puts aui_file
  end
  # now building opal version
  js_directory = "#{destination}/#{project_name}/src/js"
  opal_js = "#{js_directory}/aui.js"
  File.new opal_js, 'w'
  # we add platform_specific script to the Opal framework
  opal_content = Opal::Builder.build("#{path}aui.rb").to_s
  File.open(opal_js, 'w') do |f|
    f.puts opal_content
  end

end

def build_host_mode(destination, project_name, mode)
  path = "#{destination}/#{project_name}/src/utilities/"
  FileUtils.mkdir_p(path) unless Dir.exist?(path)
  host_type = <<~STR
    class Atome
      def self.host
        "#{mode}"
      end
    end
  STR
  File.new("#{path}host_mode.rb", 'w')
  File.open("#{path}host_mode.rb", 'w') do |f|
    f.puts host_type
  end
  # now building opal version
  js_directory = "#{destination}/#{project_name}/src/js"
  opal_js = "#{js_directory}/host_mode.js"
  File.new opal_js, 'w'
  # we add platform_specific script to the Opal framework
  opal_content = Opal::Builder.build("#{path}host_mode.rb").to_s
  File.open(opal_js, 'w') do |f|
    f.puts opal_content
  end
end

# opal compilation
def build_opal_application(_source, destination, project_name)
  # first we need to remplace all './require ' with require  so opal can parse the path
  Dir.mkdir("#{destination}/#{project_name}/tmp") unless Dir.exist?("#{destination}/#{project_name}/tmp")
  Dir.mkdir("#{destination}/#{project_name}/tmp/application") unless Dir.exist?("#{destination}/#{project_name}/tmp/application")
  process_directories("#{destination}/#{project_name}/application", "#{destination}/#{project_name}/tmp/application")

  opal_compiler_content = <<STR
# frozen_string_literal: true

require 'opal'
application_js = "../../src/js/application.js"
builder = Opal::Builder.new
builder.append_paths("./")
application_content = builder.build("./index.rb").to_s
File.open(application_js, 'w') do |f|
  f.puts application_content
end
STR
  # dossier_destination= "#{destination}/#{project_name}}/tmp/application/"

  # we create an hidden file
  opal_compiler = "#{destination}/#{project_name}/tmp/application/.opal_compiler.rb"
  File.open(opal_compiler, 'w') do |f|
    f.puts opal_compiler_content
  end
  # puts"-----------#{destination}/#{project_name}/tmp/application/.opal_compiler.rb}----------------"
  # prev_path=`pwd`.chomp
  # Dir.chdir("#{destination}/#{project_name}/tmp/application/")
  # puts `pwd`
  # opal_compiler_path = File.expand_path(".opal_compiler.rb", __dir__)
  #
  # # Utiliser require_relative avec le chemin absolu complet
  # require_relative opal_compiler_path
  # require "#{destination}/#{project_name}/tmp/application/.opal_compiler"
  # Dir.chdir(prev_path)

  puts `cd #{destination}/#{project_name}/tmp/application/;pwd;ruby .opal_compiler.rb`

  # require_relative  "#{destination}/#{project_name}/tmp/application/.opal_compiler"
  # system("#{destination}/#{project_name}/tmp/application/.opal_compiler.rb")
  ######### `ruby #{destination}/#{project_name}/tmp/application/.opal_compiler.rb` #########
  # system("#{destination}/#{project_name}/tmp/application/.opal_compiler.rb")
  # puts :kjhkjhkjhk

end

def add_to_application_folder(script_source, destination, project_name)
  # this method is to add addition script to the application folder (useful for test per example)
  destination_dir = "#{destination}/#{project_name}/application"
  FileUtils.cp_r(Dir["#{script_source}/*"], destination_dir)
end

def build_opal_library(atome_source, destination, project_name, production = nil)
  user_project_path = "#{destination}/#{project_name}"
  opal_directory = "#{user_project_path}/src/js/opal"
  opal_js = "#{opal_directory}/opal.js"
  Dir.mkdir(opal_directory) unless File.directory?(opal_directory)
  File.new opal_js, 'w'
  # we add platform_specific script to the Opal framework
  opal_content = Opal::Builder.build("#{atome_source}/lib/platform_specific/opal/opal.rb").to_s
  File.open(opal_js, 'w') do |f|
    f.puts opal_content
  end
end

def create_application(source, destination, project_name, production = nil)
  FileUtils.mkdir_p(destination) unless Dir.exist?(destination)
  FileUtils.cp_r("#{source}/vendor/assets/", "#{destination}/#{project_name}")
  build_aui(destination, project_name)
end

def build_opal_parser(source, destination, project_name)

  parser_js = "#{destination}/#{project_name}/src/js/opal/opal_parser.js"
  File.new parser_js, 'w'
  parser_content = Opal::Builder.build("#{source}/lib/platform_specific/opal/opal_parser.rb").to_s
  File.open(parser_js, 'w') do |f|
    f.puts parser_content
  end
end

def build_atome_kernel_for_opal(source, destination, project_name)
  #  now lets build the atome kernel
  atome_directory = "#{destination}/#{project_name}/src/js/atome"
  kernel_js = "#{atome_directory}/kernel.js"
  File.new kernel_js, 'w'
  builder = Opal::Builder.new
  builder.append_paths("#{source}/lib/")
  kernel_content = builder.build("#{source}/lib/atome.rb").to_s
  File.open(kernel_js, 'w') do |f|
    f.puts kernel_content
  end
end

def build_opal_extensions(source, destination, project_name)
  opal_directory = "#{destination}/#{project_name}/src/js/opal"
  extensions_js = "#{opal_directory}/atome_opal_extensions.js"
  File.new extensions_js, 'w'
  builder = Opal::Builder.new
  builder.append_paths("#{source}/lib/platform_specific/opal/")
  extensions_content = builder.build("#{source}/lib/platform_specific/opal/atome_opal_extensions.rb").to_s
  File.open(extensions_js, 'w') do |f|
    f.puts extensions_content
  end
end

# wasm compilation
def wasm_common(source, destination, project_name, wasi_file, script_source = nil)
  # create_application(source, destination, project_name)
  # the line below is to add addition script to the application folder (useful for test per example)
  if script_source
    add_to_application_folder(script_source, destination, project_name)
  end
  # build host_mode
  build_host_mode(destination, project_name, 'web-wasi')
  # build wasm
  build_for_wasm(source, destination, project_name, wasi_file)
end

# def wasm_initialize(path, app_name, wasi_source)
def wasm_initialize (source, destination, project_name, wasi_source)
  application_location = "#{destination}/#{project_name}"
  wasm_location = "#{application_location}/src/wasm/"
  Dir.mkdir(wasm_location) unless Dir.exist?(wasm_location)

  wasm_temp_folder = "#{application_location}/tmp"
  Dir.mkdir(wasm_temp_folder) unless Dir.exist?(wasm_temp_folder)
  #### IMPORTANT TO REFRESH RUBY WASM TO THE LATEST VERSION, (when ruby_browser get far too large)
  # and UNCOMMENT the line  below : ('curl -LO ....')
  unless File.exist?("#{wasm_temp_folder}/ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz")
    `cd #{wasm_temp_folder};curl -LO https://github.com/ruby/ruby.wasm/releases/latest/download/ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz`
  end
  `cd #{wasm_temp_folder}; tar xfz ruby-3_2-wasm32-unknown-wasi-full-js.tar.gz`
  `mv #{wasm_temp_folder}/3_2-wasm32-unknown-wasi-full-js/usr/local/bin/ruby #{wasm_temp_folder}/system_ruby_browser.wasm`
  `rm -f #{application_location}/src/wasm/ruby_browser.wasm`
  cmd = <<~STRDELIM
    #{application_location}/src-wasm/wasm/#{wasi_source} pack #{wasm_temp_folder}/system_ruby_browser.wasm
    --mapdir usr::#{wasm_temp_folder}/3_2-wasm32-unknown-wasi-full-js/usr
    --mapdir lib::#{source}/lib/
    --mapdir /::#{application_location}/application/
    --mapdir utilities::#{application_location}/src/utilities/
    -o #{application_location}/src/wasm/ruby_browser.wasm
  STRDELIM
  cleaned_cmd = cmd.lines.reject { |line| line.start_with?('#') }.join
  command = cleaned_cmd.chomp.gsub("\n", ' ')
  system(command)
end

def guard_check
  loop do
    sleep 1
  end
  nil unless ARGV.include?('guard')
end

def build_for_wasm(source, destination, project_name, wasi_file)
  wasm_initialize(source, destination, project_name, wasi_file)
end

def build_for_osx(destination)
  `cd #{destination};cargo tauri dev`
end

def build_for_server(destination, project_name, port, production)
  prod = '--env production' if production
  `cd #{destination}/#{project_name}/server;puma --port #{port} #{prod}`
end

# def compile_application(location)
#   `cd #{location}/src`
#   guard_check
# end

# def run_case(build_target, location, port, production)
#   case build_target
#   when :server
#     build_for_server(location, port, project_name, production)
#   when :opal
#     build_opal_library(atome_source, destination, project_name, production = nil)
#   when :wasm
#     build_for_wasm(source, destination, project_name, wasi_file)
#   when :osx
#     build_for_osx(location)
#   when :compile
#     compile_application(location)
#   when :native
#     # freebsd
#   else
#     guard_check
#   end
# end

def run_application(build_target, location, port = 9292, production = false)
  build_app(location, nil)
  run_case(build_target, location, port, production)
end

# below we analyse the ARGV
location = '/'
project_name = ARGV[1]
destination = `pwd`.chomp
source = Pathname(__FILE__).parent.parent.to_s
port = if ARGV.include?('port:')
         ARGV[ARGV.find_index('port:') + 1]
       else
         9292
       end
production = 'production' if ARGV.include?('production')
build_target = 'opal'
wasi_file = 'wasi-vfs-osx_arm' # default to osx arm
# TODO : get wasi params from ARG to allow compile on windows / Unix
if ARGV.include?('create')
  create_application(source, destination, project_name)
  # create_application(source, destination, project_name, production)
  wasm_common(source, destination, project_name, wasi_file)
  # build opal
  build_opal_library(source, destination, project_name)
  # build parser
  build_opal_parser(source, destination, project_name)
  # build atome kernel
  build_atome_kernel_for_opal(source, destination, project_name)
  # build Opal extensions
  build_opal_extensions(source, destination, project_name)
  # build application
  build_opal_application(source, destination, project_name)
end

# if ARGV.include?('rebuild')
#   # create_application(source, destination, project_name, production)
#   wasm_common(source, destination, project_name, wasi_file)
#   # build opal
#   build_opal_library(source, destination, project_name)
#   # build parser
#   build_opal_parser(source, destination, project_name)
#   # build atome kernel
#   build_atome_kernel_for_opal(source, destination, project_name)
#   # build Opal extensions
#   build_opal_extensions(source, destination, project_name)
#   # build application
#   build_opal_application(source, destination, project_name)
# end
# if ARGV.include?('run')
#   # build application
#   build_opal_application(source, destination, project_name)
# end
# if ARGV.include?('debug')
#   # build application
#   # first we need to remplace all './require ' with require  so opal can parse the path
#   # Dir.mkdir("#{destination}/#{project_name}/tmp") unless Dir.exist?("#{destination}/#{project_name}/tmp")
#   # Dir.mkdir("#{destination}/#{project_name}/tmp/application") unless Dir.exist?("#{destination}/#{project_name}/tmp/application")
#   # process_directories("#{destination}/#{project_name}/application", "#{destination}/#{project_name}/tmp/application")
#   application_js = "#{destination}/#{project_name}/src/js/application.js"
#   builder = Opal::Builder.new
#   builder.append_paths("#{destination}/#{project_name}}/tmp/application/")
#   application_content = builder.build("#{destination}/#{project_name}/tmp/application/index.rb").to_s
#   File.open(application_js, 'w') do |f|
#     f.puts application_content
#   end
# end

# if ARGV.include?('build')
#   path = found_path('build')
#   build_app(path, production)
# end

if ARGV.include?('update')
  # # TODO: also update index.html and all other files except the application folder
  # path = found_path('update')
  # update_application(path, production)
end

if ARGV.include?('guard')
  Thread.new do
    sleep 1.2
    Dir.chdir("./#{location}") do
      `guard`
    end
  end
end

if ARGV.include?('run')

  current_path = `pwd`.chomp
  segments = current_path.split("/")
  project_name = segments.last
  destination = segments[0...-1].join("/")

  # puts "running : #{destination}"
  case ARGV[1]
  when 'opal'
    build_opal_application(nil, destination, project_name)
    `open #{destination}/#{project_name}/src/index_opal.html`
  when 'wasm' # osx wasi

    #{source}/lib/
    # source = Pathname(__FILE__).parent.parent.to_s
    puts source
    # wasi_file = 'wasi-vfs-osx_arm'
    wasm_common(source, destination, project_name, wasi_file)
    `open #{current_path}/src/index.html`
  when 'server'
    threads = []
    threads << Thread.new do
      sleep 1
      `open http://localhost:9292`
    end
    build_for_server(destination, project_name, 9292, :production)

  when 'osx'
    build_for_osx(destination)
    # `open #{destination}/#{project_name}/src/index_opal.html`
  when 'android'
  when 'ios'
  when 'windows'
  when 'linux'
  when 'freebsd'
  else
  end
  # build_opal_application(nil, destination, project_name)
  # `open #{destination}/#{project_name}/src/index_opal.html`

  # path = if location != '/'
  #          "#{`pwd`.chomp}/#{location}"
  #        else
  #          found_path('run')
  #        end
  # demo_location = "#{path}/src/medias/rubies"
  #
  # filenames = Dir.glob(demo_location + '/examples/*.rb')
  # demos_list_content = []
  # filenames.each do |path|
  #   filename = File.basename(path)
  #   demos_list_content << filename
  # end
  #
  # case build_target
  # when 'android'
  #   # set_atome_mode(path,'tauri')
  #   # TODO: write code here
  # when 'browser'
  #   run_application(:browser, path)
  # when 'freebsd'
  #   # TODO: write code here
  # when 'ios'
  #   # TODO: write code here
  # when 'linux'
  #   # TODO: write code here
  # when 'osx'
  #   run_application(:osx, path)
  # when 'server'
  #   run_application(:server, path, port, production)
  # when 'windows'
  #   # TODO: write code here
  # else
  #   run_application(:browser, path)
  # end

end
