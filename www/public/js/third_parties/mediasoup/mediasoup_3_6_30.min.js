"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(a,b,c,d){d===void 0&&(d=c),Object.defineProperty(a,d,{enumerable:!0,get:function(){return b[c]}})}:function(a,b,c,d){d===void 0&&(d=c),a[d]=b[c]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(a,b){Object.defineProperty(a,"default",{enumerable:!0,value:b})}:function(a,b){a["default"]=b}),__importStar=this&&this.__importStar||function(a){if(a&&a.__esModule)return a;var b={};if(null!=a)for(var c in a)"default"!=c&&Object.hasOwnProperty.call(a,c)&&__createBinding(b,a,c);return __setModuleDefault(b,a),b};Object.defineProperty(exports,"__esModule",{value:!0}),exports.ReactNative=void 0;const sdpTransform=__importStar(require("sdp-transform")),Logger_1=require("../Logger"),errors_1=require("../errors"),utils=__importStar(require("../utils")),ortc=__importStar(require("../ortc")),sdpCommonUtils=__importStar(require("./sdp/commonUtils")),sdpPlanBUtils=__importStar(require("./sdp/planBUtils")),HandlerInterface_1=require("./HandlerInterface"),RemoteSdp_1=require("./sdp/RemoteSdp"),logger=new Logger_1.Logger("ReactNative"),SCTP_NUM_STREAMS={OS:1024,MIS:1024};class ReactNative extends HandlerInterface_1.HandlerInterface{constructor(){super(),this._sendStream=new MediaStream,this._mapSendLocalIdTrack=new Map,this._nextSendLocalId=0,this._mapRecvLocalIdInfo=new Map,this._hasDataChannelMediaSection=!1,this._nextSendSctpStreamId=0,this._transportReady=!1}static createFactory(){return()=>new ReactNative}get name(){return"ReactNative"}close(){if(logger.debug("close()"),this._pc)try{this._pc.close()}catch(a){}}async getNativeRtpCapabilities(){logger.debug("getNativeRtpCapabilities()");const a=new RTCPeerConnection({iceServers:[],iceTransportPolicy:"all",bundlePolicy:"max-bundle",rtcpMuxPolicy:"require",sdpSemantics:"plan-b"});try{const b=await a.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});try{a.close()}catch(a){}const c=sdpTransform.parse(b.sdp),d=sdpCommonUtils.extractRtpCapabilities({sdpObject:c});return d}catch(b){try{a.close()}catch(a){}throw b}}async getNativeSctpCapabilities(){return logger.debug("getNativeSctpCapabilities()"),{numStreams:SCTP_NUM_STREAMS}}run({direction:a,iceParameters:b,iceCandidates:c,dtlsParameters:d,sctpParameters:e,iceServers:f,iceTransportPolicy:g,additionalSettings:h,proprietaryConstraints:i,extendedRtpCapabilities:j}){logger.debug("run()"),this._direction=a,this._remoteSdp=new RemoteSdp_1.RemoteSdp({iceParameters:b,iceCandidates:c,dtlsParameters:d,sctpParameters:e,planB:!0}),this._sendingRtpParametersByKind={audio:ortc.getSendingRtpParameters("audio",j),video:ortc.getSendingRtpParameters("video",j)},this._sendingRemoteRtpParametersByKind={audio:ortc.getSendingRemoteRtpParameters("audio",j),video:ortc.getSendingRemoteRtpParameters("video",j)},this._pc=new RTCPeerConnection(Object.assign({iceServers:f||[],iceTransportPolicy:g||"all",bundlePolicy:"max-bundle",rtcpMuxPolicy:"require",sdpSemantics:"plan-b"},h),i),this._pc.addEventListener("iceconnectionstatechange",()=>{switch(this._pc.iceConnectionState){case"checking":this.emit("@connectionstatechange","connecting");break;case"connected":case"completed":this.emit("@connectionstatechange","connected");break;case"failed":this.emit("@connectionstatechange","failed");break;case"disconnected":this.emit("@connectionstatechange","disconnected");break;case"closed":this.emit("@connectionstatechange","closed");}})}async updateIceServers(a){logger.debug("updateIceServers()");const b=this._pc.getConfiguration();b.iceServers=a,this._pc.setConfiguration(b)}async restartIce(a){if(logger.debug("restartIce()"),this._remoteSdp.updateIceParameters(a),!!this._transportReady)if("send"===this._direction){const a=await this._pc.createOffer({iceRestart:!0});logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]",a),await this._pc.setLocalDescription(a);const b={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]",b),await this._pc.setRemoteDescription(b)}else{const a={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]",a),await this._pc.setRemoteDescription(a);const b=await this._pc.createAnswer();logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]",b),await this._pc.setLocalDescription(b)}}async getTransportStats(){return this._pc.getStats()}async send({track:a,encodings:b,codecOptions:c,codec:d}){this._assertSendDirection(),logger.debug("send() [kind:%s, track.id:%s]",a.kind,a.id),d&&logger.warn("send() | codec selection is not available in %s handler",this.name),this._sendStream.addTrack(a),this._pc.addStream(this._sendStream);let e,f=await this._pc.createOffer(),g=sdpTransform.parse(f.sdp);const h=utils.clone(this._sendingRtpParametersByKind[a.kind],{});h.codecs=ortc.reduceCodecs(h.codecs);const i=utils.clone(this._sendingRemoteRtpParametersByKind[a.kind],{});if(i.codecs=ortc.reduceCodecs(i.codecs),this._transportReady||(await this._setupTransport({localDtlsRole:"server",localSdpObject:g})),"video"===a.kind&&b&&1<b.length&&(logger.debug("send() | enabling simulcast"),g=sdpTransform.parse(f.sdp),e=g.media.find(a=>"video"===a.type),sdpPlanBUtils.addLegacySimulcast({offerMediaObject:e,track:a,numStreams:b.length}),f={type:"offer",sdp:sdpTransform.write(g)}),logger.debug("send() | calling pc.setLocalDescription() [offer:%o]",f),await this._pc.setLocalDescription(f),g=sdpTransform.parse(this._pc.localDescription.sdp),e=g.media.find(b=>b.type===a.kind),h.rtcp.cname=sdpCommonUtils.getCname({offerMediaObject:e}),h.encodings=sdpPlanBUtils.getRtpEncodings({offerMediaObject:e,track:a}),b)for(let a=0;a<h.encodings.length;++a)b[a]&&Object.assign(h.encodings[a],b[a]);if(1<h.encodings.length&&("video/vp8"===h.codecs[0].mimeType.toLowerCase()||"video/h264"===h.codecs[0].mimeType.toLowerCase()))for(const a of h.encodings)a.scalabilityMode="S1T3";this._remoteSdp.send({offerMediaObject:e,offerRtpParameters:h,answerRtpParameters:i,codecOptions:c});const j={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]",j),await this._pc.setRemoteDescription(j);const k=this._nextSendLocalId+"";return this._nextSendLocalId++,this._mapSendLocalIdTrack.set(k,a),{localId:k,rtpParameters:h}}async stopSending(a){this._assertSendDirection(),logger.debug("stopSending() [localId:%s]",a);const b=this._mapSendLocalIdTrack.get(a);if(!b)throw new Error("track not found");this._mapSendLocalIdTrack.delete(a),this._sendStream.removeTrack(b),this._pc.addStream(this._sendStream);const c=await this._pc.createOffer();logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]",c);try{await this._pc.setLocalDescription(c)}catch(a){if(0===this._sendStream.getTracks().length)return void logger.warn("stopSending() | ignoring expected error due no sending tracks: %s",a.toString());throw a}if("stable"!==this._pc.signalingState){const a={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]",a),await this._pc.setRemoteDescription(a)}}async replaceTrack(){throw new errors_1.UnsupportedError("not implemented")}async setMaxSpatialLayer(){throw new errors_1.UnsupportedError("not implemented")}async setRtpEncodingParameters(){throw new errors_1.UnsupportedError("not implemented")}async getSenderStats(){throw new errors_1.UnsupportedError("not implemented")}async sendDataChannel({ordered:a,maxPacketLifeTime:b,maxRetransmits:c,label:d,protocol:e,priority:f}){this._assertSendDirection();const g={negotiated:!0,id:this._nextSendSctpStreamId,ordered:a,maxPacketLifeTime:b,maxRetransmitTime:b,maxRetransmits:c,protocol:e,priority:f};logger.debug("sendDataChannel() [options:%o]",g);const h=this._pc.createDataChannel(d,g);if(this._nextSendSctpStreamId=++this._nextSendSctpStreamId%SCTP_NUM_STREAMS.MIS,!this._hasDataChannelMediaSection){const a=await this._pc.createOffer(),b=sdpTransform.parse(a.sdp),c=b.media.find(a=>"application"===a.type);this._transportReady||(await this._setupTransport({localDtlsRole:"server",localSdpObject:b})),logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]",a),await this._pc.setLocalDescription(a),this._remoteSdp.sendSctpAssociation({offerMediaObject:c});const d={type:"answer",sdp:this._remoteSdp.getSdp()};logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]",d),await this._pc.setRemoteDescription(d),this._hasDataChannelMediaSection=!0}const i={streamId:g.id,ordered:g.ordered,maxPacketLifeTime:g.maxPacketLifeTime,maxRetransmits:g.maxRetransmits};return{dataChannel:h,sctpStreamParameters:i}}async receive({trackId:a,kind:b,rtpParameters:c}){this._assertRecvDirection(),logger.debug("receive() [trackId:%s, kind:%s]",a,b);const d=a,e=b;let f=c.rtcp.cname;logger.debug("receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc"),f+=`-hack-${utils.generateRandomNumber()}`,this._remoteSdp.receive({mid:e,kind:b,offerRtpParameters:c,streamId:f,trackId:a});const g={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]",g),await this._pc.setRemoteDescription(g);let h=await this._pc.createAnswer();const i=sdpTransform.parse(h.sdp),j=i.media.find(a=>a.mid+""===e);sdpCommonUtils.applyCodecParameters({offerRtpParameters:c,answerMediaObject:j}),h={type:"answer",sdp:sdpTransform.write(i)},this._transportReady||(await this._setupTransport({localDtlsRole:"client",localSdpObject:i})),logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]",h),await this._pc.setLocalDescription(h);const k=this._pc.getRemoteStreams().find(a=>a.id===f),l=k.getTrackById(d);if(!l)throw new Error("remote track not found");return this._mapRecvLocalIdInfo.set(d,{mid:e,rtpParameters:c}),{localId:d,track:l}}async stopReceiving(a){this._assertRecvDirection(),logger.debug("stopReceiving() [localId:%s]",a);const{mid:b,rtpParameters:c}=this._mapRecvLocalIdInfo.get(a)||{};this._mapRecvLocalIdInfo.delete(a),this._remoteSdp.planBStopReceiving({mid:b,offerRtpParameters:c});const d={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]",d),await this._pc.setRemoteDescription(d);const e=await this._pc.createAnswer();logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]",e),await this._pc.setLocalDescription(e)}async getReceiverStats(){throw new errors_1.UnsupportedError("not implemented")}async receiveDataChannel({sctpStreamParameters:a,label:b,protocol:c}){this._assertRecvDirection();const{streamId:d,ordered:e,maxPacketLifeTime:f,maxRetransmits:g}=a,h={negotiated:!0,id:d,ordered:e,maxPacketLifeTime:f,maxRetransmitTime:f,maxRetransmits:g,protocol:c};logger.debug("receiveDataChannel() [options:%o]",h);const i=this._pc.createDataChannel(b,h);if(!this._hasDataChannelMediaSection){this._remoteSdp.receiveSctpAssociation({oldDataChannelSpec:!0});const a={type:"offer",sdp:this._remoteSdp.getSdp()};logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]",a),await this._pc.setRemoteDescription(a);const b=await this._pc.createAnswer();if(!this._transportReady){const a=sdpTransform.parse(b.sdp);await this._setupTransport({localDtlsRole:"client",localSdpObject:a})}logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]",b),await this._pc.setLocalDescription(b),this._hasDataChannelMediaSection=!0}return{dataChannel:i}}async _setupTransport({localDtlsRole:a,localSdpObject:b}){b||(b=sdpTransform.parse(this._pc.localDescription.sdp));const c=sdpCommonUtils.extractDtlsParameters({sdpObject:b});c.role=a,this._remoteSdp.updateDtlsRole("client"===a?"server":"client"),await this.safeEmitAsPromise("@connect",{dtlsParameters:c}),this._transportReady=!0}_assertSendDirection(){if("send"!==this._direction)throw new Error("method can just be called for handlers with \"send\" direction")}_assertRecvDirection(){if("recv"!==this._direction)throw new Error("method can just be called for handlers with \"recv\" direction")}}exports.ReactNative=ReactNative;