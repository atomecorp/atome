Bugs : find a solution for parent affecting the :view
- bug duplicate doesnt duplicate children ( not resolve because I dont know how to handle children id , namespace could be the solution
- lasso stop selecting is bugged
- update method : change object property without re render ( instance variable set)
- shadow is bugged!!
- video shadow badly placed
- find a solution to convert type sctipt to js
- add help and example for all api
- every api must have it's list of potions and value with it's unit ( for future conversion)
- bugs key after the key demo, then the code editor is unusable
- check monitoring on all object, on a specific property, etc..
- implement display mode : list, bloc, natural, ...
- value exchange between properties ex:  b.blur=c.color + reflexion on how tools handle this
-  esay install (on line of command) +atome create my app
- check require with code editor
- add color theme to code editor
- play events callbacks
- youtube integration
- audio recording
- documentation end users, framework users and devellopers also add how to create new type new methods and new tools
- write data flow of video player and check if all other type works the same!
- keycode to keychar
- font chooser
- cleanup demo
- detach group
- dynamic positioning and centering
- when eval should output error in console
- parser when using eval
- key press
- make eVe a gem
- text_size
- code editor : restore position and size, stop drag, text size
- key_Shortcut
- bidirectional mode
- size
- Shadow
- center
- drag
- fit
- stack events and remove (by name or order)
- init sequence
- basic U.I.
- internationalisation
- headless mode
- vocal mode
- scratch mode
- notification system : text => wait x seconds => delete
- add methods
    - staked event strategy
        optionally possible to add an id to the stacked property
        to get a stacked property ex: (please note methods are pluralized
                                    a.colors[1]
                                    or if an id is set
                                    a.colors[:id]
                                    or
                                    a.color.id(:id)
         to write or delete a stacked property ex :
                                    a.colors[1](:red)
                                    a.colors(:id)(:red)
- fit methods
- text size
- clear object (remove child)
- text selection (adding color or touch event)
- atomes namespaces
    examples :
        a=find({id: :my_atome}}
        restore(a) # note : it restore all atome's children too
        or
        restore({atome: :a.atome_id, children: child.id}) # only the child with the id 'child.id' is restore
        restore ({atome: :a.atome_id, children: false}) # only  the atome is restored
        duplicate(a)
        delete(a)
- delete methods
- time operations
- text child = font  (size color touch events) try with an image as child of text
        ex :
        text.child(5..25).color(:red)
        text.child(5..25).set({color: :blue, x: 200})
        img = image({content: :moto, x: 66, y: 66})
        infos = text({content: "object dimensions", width: 300})
        img.size(60) do |evt|
          infos.content = "width: #{img.width}\nheight: #{img.height}"
        end
        img.parent(infos.atome_id)
        infos.drag do

        end
        alert infos.child.class
- tools
 when a tool is applied on a object the properties change are time stamped and stored in the history object
-database and write strategy :
 - when an object is created it is immediately stored in the database
 - a second object is created to store the history of the first
 - a third object is created to hold the right management
 - the id of the history and authorisation objets is add ed to the master object
- database  and find api:
        examples:
        find({target: [atome_1, {user: [:jeezs, :sylvs]}, machine_1, :machine2})
        EDEn.find({user: :jeezs}) => get jeezs first level atomes
        EDEn.find({user: :jeezs, type: :image}) => get all images from jeezs
        EDEn.find({user: :jeezs, type: :image, from:{date: "01.06.2021"},  to:{date: "02.06.2021"}, width: {superior: 400} }) => get all images from a certain date with a width superior to 400
        my_atome.find({color: :red) => get all child of my_atome with a red color
        my_atome.find({type: :shape) => get all child of my_atome of type 'shape'
     how to name (root) user home's atome ? home?
- authorisation/right management
    usage:
        right on an atome, ex jeezscan change autorisation (security) , everybody can read , modification possible using password, sylvs can change the color, jeezs can delete , jeezs can share
            a.autorisation(value: {security: :jeezs}, read: all, modification: {all: {pasword: :kjhdsfgdfg54dfg}, color: {user: :sylvs}} ,delete: {user: :jeezs}, share: {user: :jeezs}}}
        advanced right on a property :
            a.color({value: :red, autorisation: { read: true, write: {user: [:jeezs, sylvz], password: :jkhgj35435},security: :jeezs}})
            or using an external security object :
            security_atome=Atome.new(autorisation: { read: true, write: {user: [:jeezs, sylvz], password: :jkhgj35435},security: :jeezs})
            a.color({value: :red, autorisation: security_atome})
- share/collaboration
- Debug
- Documentation
- repeat and wait may be atome object too!!



#old todos :
- monstruous bug when inserting an object into an other, the child lose it's position, the offset is also fucked, the bug is worse when deleting and enliven an atome!!!
- monstruous bug 2 when enliven atome child often it's drag ability and sometimes disapear
- render and enliven loose centering
- make enliven works when object has child or parent ex :  b = box({id: :toto})
                                                           b.color(:red)
                                                           t=b.text({content: :kooly, id: :titi, color: :white, y: 150})
                                                           t.y(150)
                                                           b.touch do
                                                            b.delete(true)
                                                           end
                                                           r=text({content: :reanimator,color: :orange, y: 20})
                                                           r.touch do
                                                            get(:titi).enliven(true)
                                                           end
- prevent object from beeing insert many times in the same parent
- allow this syntax a.x=b.x-c.x( not possible because of content) maybe complex property should have two kind of return a simple and a full. ex a.x => 20 a_.x_full => {content: 20 , dynamic: true}
- add and atome array and atome hash that inherit ruby array and hash to allow easy batch of atomes
- add creation of atome's array to allow batch treatment
- solve render bug (see render example)
- utilities in Neutron needs to a bit of integration to work with example
- centering is not removed when settings x or y value
- stack and allow to remove and pause  all events and specifics
- using .property method destroy event such as 'touch'
- proper delete
- proper object creation
- clean and astandardize all properties
- caret handling
- protect atome_id once writen unmodifaible
_ protect autorisation
- init sequence with db
